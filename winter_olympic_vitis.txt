#include <stdint.h>
#include <stdio.h>
#include <xil_exception.h>
#include <xintc_l.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "sleep.h"
#include "xgpio.h"
#include "xintc.h"  
#include "xuartlite.h" 
#include <string.h>
#include "xil_types.h"   // u8, u32

// ì£¼ì†Œ ì •ì˜
#define stopwatch_addr XPAR_MYIP_WINTER_STOPWATCH_0_BASEADDR
#define cooktimer_addr XPAR_MYIP_WINTER_COOKTIMER_0_BASEADDR
#define watch_addr XPAR_MYIP_WINTER_WATCH_0_BASEADDR
#define gpio_addr XPAR_AXI_GPIO_0_BASEADDR
#define fnd_addr XPAR_MYIP_FND_CNTR_0_BASEADDR
#define intc_addr XPAR_MICROBLAZE_RISCV_0_AXI_INTC_BASEADDR
#define uart_addr XPAR_XUARTLITE_0_BASEADDR
// #define pixel_addr XPAR_MYIP_PIXEL_LCD_0_BASEADDR

#define GPIO_VEC_ID XPAR_FABRIC_XGPIO_0_INTR
#define UART_VEC_ID XPAR_FABRIC_AXI_UARTLITE_0_INTR

#define btn_channel 1
#define sw_channel 2 

#define watch 0
#define speedSkating 1
#define alpineSkiing 2
#define iceHockey    3

// LCD ê´€ë ¨ ì •ì˜
#define iic0_addr XPAR_MYIP_IIC_CNTR_0_BASEADDR
#define iic1_addr XPAR_MYIP_IIC_CNTR_1_BASEADDR

#define REG_DATA_OFFSET   0  
#define REG_CTRL_OFFSET   1  
#define REG_BUSY_OFFSET   2  

#define LCD_CMD_CLEAR           0x01
#define LCD_CMD_RETURN_HOME     0x02
#define LCD_CMD_ENTRY_MODE      0x06
#define LCD_CMD_DISPLAY_ON      0x0C
#define LCD_CMD_FUNCTION_SET    0x28 
#define LCD_CMD_LINE1 0x80   // DDRAM 0x00
#define LCD_CMD_LINE2 0xC0   // DDRAM 0x40

// ì•„ì´ìŠ¤í•˜í‚¤ ìƒíƒœ ì •ì˜
#define ICE_IDLE         0    
#define ICE_PERIOD       1    // ê²½ê¸° ì‹œê°„ (20ë¶„)
#define ICE_TIMEOUT      2    // ì‘ì „ ì‹œê°„ (30ì´ˆ)
#define ICE_INTERMISSION 3    // íœ´ì‹ ì‹œê°„ (15ë¶„)

// ìŠ¤í”¼ë“œìŠ¤ì¼€ì´íŒ… 
#define TOTAL_LAPS   4
#define CSEC_PER_SEC 100

volatile int lap_count = 0;                 // ì €ì¥ëœ ë© ìˆ˜(0~4)
volatile unsigned int last_abs_sec  = 0;    // ì§ì „ Lap ëˆ„ì  sec
volatile unsigned int last_abs_csec = 0;    // ì§ì „ Lap ëˆ„ì  csec
volatile unsigned int split_sec[TOTAL_LAPS];   // ê° ë© split sec
volatile unsigned int split_csec[TOTAL_LAPS];  // ê° ë© split csec
volatile unsigned int best_split_csec = 0;  // PB(ìµœì†Œ split), 0ì´ë©´ ì•„ì§ ì—†ìŒ

volatile unsigned int *lcd0_ip_base = (unsigned int *)iic0_addr;
volatile unsigned int *lcd1_ip_base = (unsigned int *)iic1_addr;

// ------------------- LCD í•¨ìˆ˜ë“¤ ---------------------------
void LCD0_WaitBusy() { while (lcd0_ip_base[REG_BUSY_OFFSET] & 0x01); }
void LCD1_WaitBusy() { while (lcd1_ip_base[REG_BUSY_OFFSET] & 0x01); }

void LCD0_Write(u8 value, u8 is_data) {
    LCD0_WaitBusy();
    lcd0_ip_base[REG_DATA_OFFSET] = value;                           
    u32 ctrl_rs = (is_data) ? 0x02 : 0x00;
    lcd0_ip_base[REG_CTRL_OFFSET] = ctrl_rs | 0x00; 
    lcd0_ip_base[REG_CTRL_OFFSET] = ctrl_rs | 0x01; 
    for(volatile int k=0; k<100; k++); 
    lcd0_ip_base[REG_CTRL_OFFSET] = ctrl_rs | 0x00;
}

void LCD1_Write(u8 value, u8 is_data) {
    LCD1_WaitBusy();
    lcd1_ip_base[REG_DATA_OFFSET] = value;
    u32 ctrl_rs = (is_data) ? 0x02 : 0x00;
    lcd1_ip_base[REG_CTRL_OFFSET] = ctrl_rs | 0x00; 
    lcd1_ip_base[REG_CTRL_OFFSET] = ctrl_rs | 0x01; 
    for(volatile int k=0; k<100; k++); 
    lcd1_ip_base[REG_CTRL_OFFSET] = ctrl_rs | 0x00;
}

void LCD0_SendCommand(u8 cmd) { LCD0_Write(cmd, 0); }
void LCD1_SendCommand(u8 cmd) { LCD1_Write(cmd, 0); }
void LCD0_SendData(u8 data) { LCD0_Write(data, 1); }
void LCD1_SendData(u8 data) { LCD1_Write(data, 1); }

void LCD0_Init_Soft() {
    usleep(100000); 
    LCD0_SendCommand(LCD_CMD_FUNCTION_SET);
    LCD0_SendCommand(LCD_CMD_DISPLAY_ON); 
    LCD0_SendCommand(LCD_CMD_ENTRY_MODE); 
    LCD0_SendCommand(LCD_CMD_CLEAR);      
}

void LCD1_Init_Soft() {
    usleep(100000); 
    LCD1_SendCommand(LCD_CMD_FUNCTION_SET);
    LCD1_SendCommand(LCD_CMD_DISPLAY_ON); 
    LCD1_SendCommand(LCD_CMD_ENTRY_MODE); 
    LCD1_SendCommand(LCD_CMD_CLEAR);      
}

void LCD0_PrintString(char *str) { while(*str) { LCD0_SendData(*str++); } }
void LCD1_PrintString(char *str) { while(*str) { LCD1_SendData(*str++); } }

// 16ì¹¸ ê³ ì • ì¶œë ¥(ë‚¨ëŠ” ì¹¸ ê³µë°±)
static void LCD0_Print16(u8 line_cmd, const char *s)
{
    char buf[17];
    int n = (int)strlen(s);
    if (n > 16) n = 16;
    for (int i=0;i<16;i++) buf[i] = ' ';
    for (int i=0;i<n;i++)  buf[i] = s[i];
    buf[16] = '\0';
    LCD0_SendCommand(line_cmd);
    LCD0_PrintString(buf);
}

static void LCD1_PrintN(const char *s, int n) // nê¸€ìë§Œ ì¶œë ¥(ë¶€ì¡±í•˜ë©´ ê³µë°±)
{
    for (int i=0;i<n;i++) {
        char c = (s && s[i]) ? s[i] : ' ';
        LCD1_SendData((u8)c);
    }
}
// -----------------------------------------------------------------------


// -----------------------------------------------------------------------

XUartLite uart_device;
XIntc intc; 
XGpio gpio_device; 

unsigned int *stopwatch_device = (unsigned int*) stopwatch_addr;
unsigned int *watch_device = (unsigned int*) watch_addr;
unsigned int *cooktimer_device = (unsigned int*) cooktimer_addr;
// unsigned int *pixel_device = (unsigned int*) pixel_addr;
unsigned int *fnd_device = (unsigned int*)fnd_addr; 

static inline void alarm_on(){
    cooktimer_device[5] = 1;
}

static inline void alarm_off(){
    cooktimer_device[5] = 0;
}

static void alarm_pulse(){
    alarm_on();
    usleep(200000);
    alarm_off();
}

void Gpio_Handler(void *CallBackRef);
void RecvHandler(void *CallBackRef, unsigned int EventData);
void SendHandler(void *CallBackRef, unsigned int EventData);

volatile char btn_flag = 0;
volatile char sw_flag = 0; // ìŠ¤ìœ„ì¹˜ ë³€ê²½ ê°ì§€ìš© í”Œë˜ê·¸

// 1. ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
volatile char uart_rx_data = 0;
volatile int uart_rx_flag = 0;

// ì „ì—­ ë³€ìˆ˜ ì¶”ê°€
volatile unsigned int shared_btn_value = 0;
volatile unsigned int seoul_hour, seoul_min, seoul_sec =0;
volatile unsigned int milan_hour;

void milan_change(){
    unsigned int current_seoul_hour = watch_device[4];
    
    if(current_seoul_hour >= 8)  
        milan_hour = current_seoul_hour - 8;
    else  
        milan_hour = current_seoul_hour + 16;
}


// ------------------- ì•„ì´ìŠ¤í•˜í‚¤ í—¬í¼ í•¨ìˆ˜ -------------------
void hockey_start_timer(int seconds) {
    int min = seconds / 60;
    int sec = seconds % 60;

    cooktimer_device[2] = 0b10;   // ì •ì§€
    usleep(10000);

    cooktimer_device[0] = sec;
    cooktimer_device[1] = min;

    cooktimer_device[2] = 0b01;   // start í„ìŠ¤ (ë”± 1ë²ˆ)
    usleep(1000);
    cooktimer_device[2] = 0x00;
}

void hockey_pause_timer() {
    cooktimer_device[2] = 0b10;      // alarm_off
}

void hockey_resume_timer() {
    int cur = hockey_get_remaining_time();
    int min = cur / 60;
    int sec = cur % 60;

    cooktimer_device[2] = 0b10;   // ì¼ë‹¨ ì •ì§€
    usleep(1000);

    // ğŸ”´ í•µì‹¬: í˜„ì¬ ê°’ìœ¼ë¡œ load ê°±ì‹ 
    cooktimer_device[0] = sec;
    cooktimer_device[1] = min;

    cooktimer_device[2] = 0b01;   // start í„ìŠ¤
    usleep(1000);
    cooktimer_device[2] = 0;
}

void hockey_clear_timer(){
    cooktimer_device[2] = 0b10;
    usleep(10000);
    cooktimer_device[2] = 0;
    cooktimer_device[0] = 0;
    cooktimer_device[1] = 0;
}
void hockey_hard_reset_timer() {
    cooktimer_device[2] = 0;        // ëª¨ë“  ì œì–´ ë¹„íŠ¸ LOW
    usleep(10000);

    cooktimer_device[0] = 0;        // sec
    cooktimer_device[1] = 0;        // min
    usleep(10000);

    cooktimer_device[2] = 0b10;     // alarm_off ê°•ì œ
    usleep(10000);
    cooktimer_device[2] = 0;        // ì™„ì „ í´ë¦¬ì–´
}

int hockey_get_remaining_time() {
    int min = cooktimer_device[4];       // ë¶„ ì½ê¸°
    int sec = cooktimer_device[3];       // ì´ˆ ì½ê¸°
    return (min * 60) + sec;             // ì´ˆë¡œ ë³€í™˜
}

// ------------------- ìŠ¤í”¼ë“œìŠ¤ì¼€ì´íŒ… í—¬í¼ í•¨ìˆ˜ -------------------

static inline void Stopwatch_ToggleStartStop(void)
{
    stopwatch_device[0] |= 0b001;
    stopwatch_device[0] &= ~0b001;
}

// ëˆ„ì (sec,csec) -> total_csec ë³€í™˜
static inline unsigned int to_csec(unsigned int sec, unsigned int csec)
{
    return sec * CSEC_PER_SEC + (csec % CSEC_PER_SEC);
}

// total_csec -> (sec,csec) ë³€í™˜
static inline void from_csec(unsigned int total_csec, unsigned int *sec, unsigned int *csec)
{
    *sec = total_csec / CSEC_PER_SEC;
    *csec = total_csec % CSEC_PER_SEC;
}

// ê¸°ë¡ ì „ì²´ ì´ˆê¸°í™” (Clear ë²„íŠ¼ì—ì„œ ì‚¬ìš©)
static void Speed_Reset(void)
{
    lap_count = 0;
    last_abs_sec = 0;
    last_abs_csec = 0;
    best_split_csec = 0;

    for (int i=0;i<TOTAL_LAPS;i++) {
        split_sec[i] = 0;
        split_csec[i] = 0;
    }
}

// LCD0 2ì¤„(BEST)ë§Œ ê°±ì‹ 
static void Speed_UpdateBestLine(void)
{
    char best_line[17];
    if (best_split_csec == 0) {
        snprintf(best_line, sizeof(best_line), "BEST:--.--");
    } else {
        unsigned int bs, bc;
        from_csec(best_split_csec, &bs, &bc);
        snprintf(best_line, sizeof(best_line), "BEST:%02u.%02u", bs, bc);
    }
    LCD0_Print16(LCD_CMD_LINE2, best_line);
}

// idx(0~3) í•´ë‹¹ ë© "8ì¹¸"ë§Œ LCD1ì˜ ì •í™•í•œ ìœ„ì¹˜ì— ì¶œë ¥
static void Speed_UpdateOneLapCell(int idx)
{
    // L1(1~2ë©): base=LINE1, col=0 or 8
    // L2(3~4ë©): base=LINE2, col=0 or 8
    u8 base = (idx < 2) ? LCD_CMD_LINE1 : LCD_CMD_LINE2;
    u8 col  = (idx % 2) * 8;
    LCD1_SendCommand((u8)(base + col));

    char cell[9];
    int lap_no = idx + 1;

    if (lap_count >= lap_no) {
        // 8ì¹¸ ì•ˆì— ë“¤ì–´ê°€ëŠ” í¬ë§·: "n:SS.CC" (ìµœëŒ€ 7ê¸€ì) + ê³µë°± padding
        snprintf(cell, sizeof(cell), "%d:%02u.%02u", lap_no, split_sec[idx], split_csec[idx]);
    } else {
        snprintf(cell, sizeof(cell), "%d:--.--", lap_no);
    }

    // 8ì¹¸ ê³ ì • ì¶œë ¥(ë¶€ì¡±í•œ ê¸€ìëŠ” LCD1_PrintNì—ì„œ ê³µë°±ìœ¼ë¡œ ì±„ì›€)
    LCD1_PrintN(cell, 8);
}

// speed skating í™”ë©´ í”„ë ˆì„(ì´ˆê¸° í™”ë©´) ì¶œë ¥
static void Speed_ShowFrame(void)
{
    // LCD0 1ì¤„: ëª¨ë“œ ê³ ì • ë¬¸êµ¬
    LCD0_Print16(LCD_CMD_LINE1, "SPEED SKATING");
    // LCD0 2ì¤„: BEST í‘œì‹œ
    Speed_UpdateBestLine();

    // LCD1: 4ê°œ ì¹¸ ëª¨ë‘ placeholder ì¶œë ¥
    Speed_UpdateOneLapCell(0);
    Speed_UpdateOneLapCell(1);
    Speed_UpdateOneLapCell(2);
    Speed_UpdateOneLapCell(3);
}

// Lap ë²„íŠ¼ ì²˜ë¦¬: ì´ë²ˆ split ê³„ì‚°/ì €ì¥ + BEST ê°±ì‹  + "í•´ë‹¹ ì¹¸ë§Œ" LCD ì—…ë°ì´íŠ¸
static void Speed_OnLap(void)
{
    if (lap_count >= TOTAL_LAPS) {
        xil_printf("Already finished 4 laps.\r\n");
        return;
    }

    // Stopwatch IP ëˆ„ì  ì‹œê°„ ì½ê¸°
    unsigned int abs_sec  = stopwatch_device[1];
    unsigned int abs_csec = stopwatch_device[2] % CSEC_PER_SEC;

    // now_total - last_total = ì´ë²ˆ Lap split
    unsigned int now_total  = to_csec(abs_sec, abs_csec);
    unsigned int last_total = to_csec(last_abs_sec, last_abs_csec);
    if (now_total < last_total) now_total = last_total; // ì•ˆì „ì¥ì¹˜

    unsigned int split_total = now_total - last_total;

    // split_totalì„ sec/csecë¡œ ë³€í™˜í•´ì„œ ì €ì¥
    unsigned int sp_s, sp_c;
    from_csec(split_total, &sp_s, &sp_c);

    int idx = lap_count; // ì´ë²ˆì— ì €ì¥í•  ë© ì¸ë±ìŠ¤(0~3)

    split_sec[idx]  = sp_s;
    split_csec[idx] = sp_c;

    // PB ê°±ì‹ (ìµœì´ˆ ë˜ëŠ” ë” ì‘ì€ splitì´ë©´ ì—…ë°ì´íŠ¸)
    if (best_split_csec == 0 || split_total < best_split_csec) {
        best_split_csec = split_total;
    }

    lap_count++;

    // ë‹¤ìŒ split ê³„ì‚°ì„ ìœ„í•œ ê¸°ì¤€ì (ì§ì „ ëˆ„ì ì‹œê°„) ê°±ì‹ 
    last_abs_sec  = abs_sec;
    last_abs_csec = abs_csec;

    xil_printf("Lap %d split=%u.%02u  (BEST=%u.%02u)\r\n",
               lap_count, sp_s, sp_c,
               best_split_csec / CSEC_PER_SEC, best_split_csec % CSEC_PER_SEC);

    // â˜… LCD ê°±ì‹ ì€ "ì´ë²ˆ ë© ì¹¸(8ì¹¸)"ë§Œ ì—…ë°ì´íŠ¸í•´ì„œ ì˜† ì¹¸ ì˜í–¥ ë°©ì§€
    Speed_UpdateOneLapCell(idx);

    // BEST ë¼ì¸ë§Œ ì—…ë°ì´íŠ¸
    Speed_UpdateBestLine();

    if (lap_count >= TOTAL_LAPS) {
        Stopwatch_ToggleStartStop();   // start/stop í† ê¸€ -> stop
        xil_printf("4 LAPS DONE -> AUTO STOP\r\n");
    }
}
// ============================================================

int main(){
    init_platform();
   
    XUartLite_Initialize(&uart_device, uart_addr);
    XGpio_Initialize(&gpio_device, gpio_addr);

    XGpio_SetDataDirection(&gpio_device, btn_channel, 0xf);
    XGpio_SetDataDirection(&gpio_device, sw_channel, 0xffff);
    
    // [ì¶”ê°€] LCD ì´ˆê¸°í™” (í•„ìˆ˜)
    LCD0_Init_Soft();
    LCD1_Init_Soft();

    XIntc_Initialize(&intc, intc_addr);
    XIntc_Connect(&intc, GPIO_VEC_ID, Gpio_Handler, (void *)&gpio_device);
    XIntc_Connect(&intc, UART_VEC_ID, (XInterruptHandler) XUartLite_InterruptHandler, (void *)&uart_device);                                    
                                    
    XIntc_Enable(&intc, GPIO_VEC_ID); 
    XIntc_Enable(&intc, UART_VEC_ID); 
    XIntc_Start(&intc, XIN_REAL_MODE);

    XGpio_InterruptEnable(&gpio_device, btn_channel); 
    XGpio_InterruptEnable(&gpio_device, sw_channel); 
    XGpio_InterruptGlobalEnable(&gpio_device);

    XUartLite_SetRecvHandler(&uart_device, RecvHandler, (void *)&uart_device);
    XUartLite_SetSendHandler(&uart_device, SendHandler, (void *)&uart_device);
    XUartLite_EnableInterrupt(&uart_device);
    
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XIntc_InterruptHandler, (void *)&intc);
    Xil_ExceptionEnable();  
        
    print("System Started\n");
    fnd_device[1] = 1; 

    // print("Initializing Pixel LCD (ILI9341)...\n");
    // // volatile unsigned int *pixel_cntr = (unsigned int*)(pixel_addr +4);
    // // *pixel_cntr = 1;
    // // usleep(10000);
    // // *pixel_cntr = 0;
    // usleep(120000);
    // print("Pixel LCD reset complete\n");
    // // pixel_device[0] = 0;
    // print("Pixel LCD initialization done\n");

    //watch ì‹œê°„ ì„¤ì •
    seoul_hour = 07;
    seoul_min = 59;
    seoul_sec = 55;

    watch_device[0] =seoul_hour;
    watch_device[1] =seoul_min;
    watch_device[2] =seoul_sec;


   // 2. Load ì‹ í˜¸ ë°œìƒ (0ë²ˆ ë¹„íŠ¸ê°€ loadë¼ê³  ê°€ì •)
    watch_device[3] |= (1 << 0);  // Load ì‹ í˜¸ High (0 -> 1 ìƒìŠ¹ ì—£ì§€ ë°œìƒ)
    usleep(10);                   // í•˜ë“œì›¨ì–´ê°€ ì¸ì‹í•  ì•„ì£¼ ì§§ì€ ì‹œê°„ ëŒ€ê¸°
    watch_device[3] &= ~(1 << 0); // Load ì‹ í˜¸ Low (ë‹¤ìŒ ì„¤ì •ì„ ìœ„í•´ ì´ˆê¸°í™”)

    int mode = 0; 
    int prev_mode = -1;
    char lcd_buff[32];
    int loop_cnt = 0;
    int penalty_time = 0;

    // ì•„ì´ìŠ¤í•˜í‚¤ ì „ì—­ ë³€ìˆ˜
    int hockey_state = ICE_IDLE;      
    int hockey_period = 1;              // í˜„ì¬ í”¼ë¦¬ì–´ë“œ (1~3)
    int hockey_timer_running = 0;       // íƒ€ì´ë¨¸ ë™ì‘ ì—¬ë¶€
    int hockey_saved_time = 0;          // ì‘ì „íƒ€ì„ ì‹œ ì €ì¥í•  ê²½ê¸° ì‹œê°„
    int hockey_prev_time = -1;

    // speed skating ì´ˆê¸° í™”ë©´
    Speed_Reset();
    LCD0_SendCommand(LCD_CMD_CLEAR);
    LCD1_SendCommand(LCD_CMD_CLEAR);
    usleep(2000);
    Speed_ShowFrame();

    // [ì¤‘ìš”] ì²« ë²ˆì§¸ ë°ì´í„°ë¥¼ ë°›ì„ ì¤€ë¹„ (ë©ì„ ê¹”ê¸°)
    XUartLite_Recv(&uart_device, (u8*)&uart_rx_data, 1);

    static const unsigned int schedule[3][3] = {
        {04, 30, 0},   // ìŠ¤í”¼ë“œìŠ¤ì¼€ì´íŒ…
        {19,  0, 0},   // ì•ŒíŒŒì¸ìŠ¤í‚¤
        {23, 15, 0},   // ì•„ì´ìŠ¤í•˜í‚¤
    };
    static char schedule_fired[3] = {0, 0, 0};

    while(1)
    {   
        unsigned int current_sec = stopwatch_device[1];
        unsigned int current_csec = stopwatch_device[2];
        milan_change();



        if(uart_rx_flag) {
        XUartLite_Recv(&uart_device, (u8*)&uart_rx_data, 1);
        xil_printf("Data received: %c\r\n", uart_rx_data);

        uart_rx_flag = 0; // í”Œë˜ê·¸ ì´ˆê¸°í™”
        }

        // 1. ìŠ¤ìœ„ì¹˜ ê°’ìœ¼ë¡œ ëª¨ë“œ ì„¤ì •
        unsigned int sw_val = XGpio_DiscreteRead(&gpio_device, sw_channel);
        
            // 1. ëª¨ë“œ ì„ íƒ (Switch)
        switch (sw_val & 0x0F) { // 0x01, 0x02, 0x04, 0x08 ë¹„íŠ¸ ì²´í¬
        case 0x01: mode = watch ; break;
        case 0x02: mode = speedSkating; break;
        case 0x04: mode = alpineSkiing; break;
        case 0x08: mode = iceHockey; break;
        default: mode = watch; // ìƒíƒœ ìœ ì§€ í•„ìš” ì‹œ ì¶”ê°€
        }



       // 2. ë²„íŠ¼ ì²˜ë¦¬ (ëª¨ë“œë³„ ë™ì‘ ë¶„ê¸°)
        if (btn_flag) {
        btn_flag = 0;    
        print("btn_flag=0\n");
        unsigned int btn_value = shared_btn_value; // ì €ì¥ëœ ê°’ ì‚¬ìš©

        switch (mode) {
            case speedSkating: // [ìŠ¤í†±ì›Œì¹˜ ëª¨ë“œ]
                switch (btn_value) {
                    case 1: // btn 0 - Start/Stop
                        stopwatch_device[0] |= 0b001;
                        stopwatch_device[0] &= ~0b001;
                        xil_printf("start/stop\n");

                        while (XGpio_DiscreteRead(&gpio_device, btn_channel) != 0) { }
                        usleep(30000);
                        break;
                    
                    case 2: // Lap
                        if(lap_count == 3){
                            alarm_pulse();
                        }
                        Speed_OnLap();
                        while (XGpio_DiscreteRead(&gpio_device, btn_channel) != 0) { }
                        usleep(30000);
                        break;

                    case 4: // Clear
                        // Clearì—ì„œë§Œ ê¸°ë¡ ì´ˆê¸°í™”
                        Speed_Reset();
                        Speed_ShowFrame();

                        stopwatch_device[0] |= 0b100;
                        stopwatch_device[0] &= ~0b100;
                        xil_printf("clear\n");

                        while (XGpio_DiscreteRead(&gpio_device, btn_channel) != 0) { }
                        usleep(30000);
                        break;
                }
                    
              
                break;

            case alpineSkiing: 
                 switch (btn_value) {
                    case 1: stopwatch_device[0] |= 0b001; stopwatch_device[0] &= ~0b001; print("start\n"); break; // Start
                    case 2: stopwatch_device[0] |= 0b010; stopwatch_device[0] &= ~0b010; print("lap\n"); break; // Lap
                    case 4: stopwatch_device[0] |= 0b100; stopwatch_device[0] &= ~0b100; penalty_time = 0; print("clear\n");break; // Clear
                    case 8: alarm_pulse(); penalty_time += 3; usleep(200000); print("Penalty +3s\n");  break;   // ë²Œì  ëˆ„ì 
                }
                
                break;

            case iceHockey:
                switch (btn_value){
                    case 1: // btn0 - start/pause
                        switch(hockey_state){
                            case ICE_IDLE:
                                hockey_hard_reset_timer();
                                hockey_state = ICE_PERIOD;
                                hockey_timer_running = 1;
                                hockey_start_timer(20*2);
                                usleep(100000);
                                print("GAME START\n");
                                break;

                            case ICE_PERIOD:
                                if(hockey_timer_running){
                                    hockey_pause_timer();
                                    hockey_timer_running = 0;
                                }
                                else{
                                    hockey_resume_timer();
                                    hockey_timer_running = 1;
                                }
                                break;
                        }
                        break;

                    case 2: // btn1 - timeout
                        if(hockey_state == ICE_PERIOD && hockey_timer_running){
                            hockey_saved_time = hockey_get_remaining_time();
                            hockey_pause_timer();
                            hockey_state = ICE_TIMEOUT;
                            hockey_timer_running = 1;
                            hockey_start_timer(3);
                        }
                        break;
                    
                    case 4: // btn2 - HARD RESET
                        hockey_hard_reset_timer();

                        hockey_state = ICE_IDLE;
                        hockey_period = 1;
                        hockey_timer_running = 0;
                        hockey_saved_time = 0;
                        hockey_prev_time = -1;

                        print("Hockey HARD RESET\n");
                        break;

                }
                break;

            case watch: // [ì‹œê³„ ëª¨ë“œ]
                switch(btn_value){
                    case 1: // btn0 - hour++
                        seoul_hour = (seoul_hour +1)%24;
                        break;
                    case 2: // btn1 - min++
                        seoul_min = (seoul_min +1)%60;
                        break;
                    case 4: // btn2 - sec++
                        seoul_sec = (seoul_sec +1)%60;
                        break;
                    case 8: // btn3 - reset
                        seoul_hour = 0;
                        seoul_min = 0;
                        seoul_sec = 0;
                        break;
                }

                watch_device[0] = seoul_hour;
                watch_device[1] = seoul_min;
                watch_device[2] = seoul_sec;

                watch_device[3] |= (1 << 0);
                usleep(10);
                watch_device[3] &= ~(1 << 0);
                break;
        }
        }

        // ìë™ ì „í™˜ ë¡œì§ ë¶€ë¶„ ìˆ˜ì •
        if (mode == iceHockey && hockey_timer_running){
            int current_time = hockey_get_remaining_time();
    
            // ì´ì „ ì‹œê°„ì´ 0ë³´ë‹¤ í¬ê³ , í˜„ì¬ 0ì´ ëœ ê²½ìš°ì—ë§Œ ì „í™˜
            if(current_time == 0 && hockey_prev_time > 0){
                switch (hockey_state){
                 case ICE_PERIOD:
                        alarm_pulse();
                        if(hockey_period < 3){
                            hockey_state = ICE_INTERMISSION;
                         hockey_start_timer(15*2);
                         hockey_prev_time = -1; // ë¦¬ì…‹
                         print("INTERMISSION\n");
                      }
                      else{
                          hockey_state = ICE_IDLE;
                          hockey_period = 1;
                          hockey_timer_running = 0;
                          hockey_prev_time = -1; // ë¦¬ì…‹
                          hockey_clear_timer();
                          print("GAME OVER\n");
                      }
                     break;

                  case ICE_TIMEOUT:
                      hockey_state = ICE_PERIOD;
                      hockey_start_timer(hockey_saved_time);
                       hockey_prev_time = -1; // ë¦¬ì…‹
                     print("TIMEOUT END\n");
                     break;
            
                 case ICE_INTERMISSION:
                      hockey_period++;
                      hockey_state = ICE_PERIOD;
                      hockey_start_timer(20*2);
                     hockey_prev_time = -1; // ë¦¬ì…‹
                      print("NEXT PERIOD START\n");
                     break;
                }
            }
        hockey_prev_time = current_time; // í˜„ì¬ ì‹œê°„ ì €ì¥
        }


        // 3. ëª¨ë“œ ë³€ê²½ ì‹œ í™”ë©´ í´ë¦¬ì–´ ë° ì´ˆê¸° ë¬¸êµ¬ ì¶œë ¥
        if (mode != prev_mode) {
        stopwatch_device[0] = 0;
        stopwatch_device[0] |= 0b100;   // clear
        stopwatch_device[0] &= ~0b100;
        cooktimer_device[2] = 0;
        fnd_device[0] = 0;
        // pixel_device[0] = mode;
        LCD0_SendCommand(LCD_CMD_CLEAR);
        LCD1_SendCommand(LCD_CMD_CLEAR);
        usleep(2000); 

        switch (mode) {
            case speedSkating:
                Speed_Reset();
                stopwatch_device[0] |= 0b100;  // clear
                stopwatch_device[0] &= ~0b100;
                Speed_ShowFrame();
                break;
            case alpineSkiing:
                LCD0_SendCommand(0x80);
                LCD0_PrintString("ALPINE SKIING");
                usleep(10000);
                LCD0_SendCommand(0xC0); 
                usleep(10000);
                LCD0_PrintString("MILANO-CORTINA ");

                LCD1_SendCommand(0x80);
                LCD1_PrintString("RECORD SEC CSEC ");
                break;
            case iceHockey:
                LCD0_SendCommand(0x80);
                LCD0_PrintString("MILANO-CORTINA");
                usleep(10000);
                LCD0_SendCommand(0xC0);
                usleep(10000);
                LCD0_PrintString("ICE HOCKEY ");

                LCD1_SendCommand(0x80);
                LCD1_PrintString("MODE    TIME");
                break;
            case watch: 
                LCD0_PrintString("   SEOUL TIME   ");
                LCD1_PrintString("   MILAN TIME   ");
                break;
        }
        prev_mode = mode;
        }

        // 4. ì‹¤ì‹œê°„ LCD ë° FND ê°±ì‹  (í•­ìƒ ì‹¤í–‰ë˜ëŠ” êµ¬ê°„)
        if (mode == alpineSkiing) {
        int total_sec = current_sec + penalty_time; // í•˜ë“œì›¨ì–´ ì´ˆ + ëˆ„ì  ë²Œì 

        // LCD ì‹œê°„ ì—…ë°ì´íŠ¸ (ë‘ ë²ˆì§¸ ì¤„)
        LCD1_SendCommand(0xC0); 
        sprintf(lcd_buff, "TIME  %d:%02d %d ", total_sec, current_csec,penalty_time/3); 
        LCD1_PrintString(lcd_buff);
        } 

        if (mode == watch) {
        // LCD ì‹œê°„ ì—…ë°ì´íŠ¸ (ë‘ ë²ˆì§¸ ì¤„)
        LCD0_SendCommand(0xC0); 
        sprintf(lcd_buff, "    %02d:%02d:%02d    ", watch_device[4], watch_device[5],watch_device[6]); 
        LCD0_PrintString(lcd_buff);

        LCD1_SendCommand(0xC0); 
        sprintf(lcd_buff, "    %02d:%02d:%02d    ", milan_hour, watch_device[5],watch_device[6]); 
        LCD1_PrintString(lcd_buff);

        } 

        else if(mode == iceHockey){
            int min = 0;
            int sec = 0;

            char state_str[8];
            switch(hockey_state){
                case ICE_IDLE:
                    sprintf(state_str, "IDLE");
                    break;
                case ICE_PERIOD:
                    sprintf(state_str, "P%d", hockey_period);
                    min = hockey_get_remaining_time() / 60;
                    sec = hockey_get_remaining_time() % 60;
                    break;
                case ICE_TIMEOUT:
                    sprintf(state_str, "T/O");
                    min = hockey_get_remaining_time() / 60;
                    sec = hockey_get_remaining_time() % 60;
                    break;
                case ICE_INTERMISSION:
                    sprintf(state_str, "INT");
                    min = hockey_get_remaining_time() / 60;
                    sec = hockey_get_remaining_time() % 60;
                    break;
            }

    sprintf(lcd_buff, "%-4s    %02d:%02d   ", state_str, min, sec);
    LCD1_SendCommand(0xc0);
    LCD1_PrintString(lcd_buff);

    xil_printf("State:%d Running:%d Time:%d\n",
        hockey_state, hockey_timer_running,
        (hockey_state == ICE_IDLE) ? 0 : hockey_get_remaining_time());
    }





        //4. fnd ì¶œë ¥    
        switch(mode){
            case speedSkating:    fnd_device[0] = ((stopwatch_device[1]/10)<<12) 
                                                +((stopwatch_device[1]%10)<<8) 
                                                +((stopwatch_device[2]/10)<<4) 
                                                +(stopwatch_device[2]%10);      break;
            case alpineSkiing:   fnd_device[0] = ((stopwatch_device[1]/10)<<12) 
                                                +((stopwatch_device[1]%10)<<8) 
                                                +((stopwatch_device[2]/10)<<4) 
                                                +(stopwatch_device[2]%10);      break;
            case iceHockey: {
                int remaining;

                if (hockey_state == ICE_IDLE) {
                    remaining = 0;   // âœ… IDLEì´ë©´ ë¬´ì¡°ê±´ 0
                } 
                else {
                    remaining = hockey_get_remaining_time();
                }

                int min = remaining / 60;
                int sec = remaining % 60;

                fnd_device[0] = ((min/10)<<12)
                              + ((min%10)<<8)
                              + ((sec/10)<<4)
                              + (sec%10);
                break;
            }
            case watch: 
                int hour = watch_device[4];
                int min = watch_device[5];

                fnd_device[0] = ((hour/10)<<12)
                              + ((hour%10)<<8)
                              + ((min/10)<<4)
                              + (min%10);
                break;



        }



        // // 4. í™”ë©´ ê°±ì‹  (ë„ˆë¬´ ë¹ ë¥´ë©´ LCD ê¸€ì ê¹¨ì§€ë¯€ë¡œ ì†ë„ ì¡°ì ˆ)
        // if(loop_cnt++ > 50000) { 
        //     loop_cnt = 0;
        //     LCD1_SendCommand(LCD_CMD_RETURN_HOME); // ì»¤ì„œ ìœ„ì¹˜ ì´ˆê¸°í™”

        //     if (mode == 0) { // ìŠ¤í†±ì›Œì¹˜ ê°’ ì¶œë ¥
        //         unsigned int sec = stopwatch_device[1];
        //         unsigned int msec = stopwatch_device[2];

        //         // FND ì¶œë ¥
        //         fnd_device[0] = ((sec/10)<<12) + ((sec%10)<<8) + ((msec/10)<<4) + (msec%10);
                
        //         // LCD ì¶œë ¥
        //         sprintf(lcd_buff, "Time: %02d.%02d   ", sec, msec);
        //         LCD1_PrintString(lcd_buff);
        //     }
        //     else if (mode == 1) { // ì¿¡íƒ€ì´ë¨¸ ì¶œë ¥
        //         fnd_device[0] = 0xCCCC; // Cook í‘œì‹œ
        //         LCD1_PrintString("Cook Timer...   ");
        //     }
        //     else if (mode == 2) { // ì‹œê³„ ì¶œë ¥
        //         fnd_device[0] = 0x8888; // Watch í‘œì‹œ
        //         LCD1_PrintString("Digital Watch   ");
        //     }
        // }
    }

    cleanup_platform();
    return 0;
}

// ------------------- ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ -------------------
void Gpio_Handler(void *CallBackRef){
    XGpio *gpio_ptr = (XGpio *)CallBackRef;
    
    unsigned int isr = XGpio_InterruptGetStatus(gpio_ptr);
                 
    if (isr & 1) { // ë²„íŠ¼
        unsigned int current_btn = XGpio_DiscreteRead(gpio_ptr, btn_channel);
        // ì¤‘ìš”: ë²„íŠ¼ì„ ëˆ„ë¥¸ ìƒíƒœ(0ì´ ì•„ë‹˜)ì¼ ë•Œë§Œ ë©”ì¸ ë£¨í”„ì— ì•Œë¦¼
        if (current_btn != 0) {
            shared_btn_value = current_btn;
            btn_flag = 1;
            xil_printf("Button Pressed: %d\r\n", shared_btn_value);
        }
        XGpio_InterruptClear(gpio_ptr, btn_channel);
    }
    
    if (isr & 2) { // ìŠ¤ìœ„ì¹˜
        sw_flag = 1; 
        print("switch interrupt\r\n");
        XGpio_InterruptClear(gpio_ptr, sw_channel);
    }
} 

void RecvHandler(void *CallBackRef, unsigned int EventData){
    // xil_printfë¥¼ ì§€ìš°ê³  ë°ì´í„°ë§Œ ì½ì–´ì„œ ì €ì¥í•©ë‹ˆë‹¤.

    uart_rx_flag = 1; // ë©”ì¸ ë£¨í”„ì—ê²Œ ë°ì´í„° ì™”ë‹¤ê³  ì•Œë¦¼
}

void SendHandler(void *CallBackRef, unsigned int EventData){
    return;
}